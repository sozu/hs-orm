{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE IncoherentInstances #-}

module Database.ORM.Insert (
    insertNodes
) where

import Control.Monad.State
import qualified Data.List as L
import Data.IORef
import Data.Maybe (catMaybes)
import GHC.TypeLits
import Data.Proxy
import Database.HDBC
import Data.Model.Graph
import Database.ORM.HDBC
import Database.ORM.Query
import Database.ORM.Record

-- | Inserts nodes in a graph into database.
insertNodes :: forall db g a. (WithDB db, GraphContainer g a, RecordWrapper a, EdgeMap g g a)
            => g -- ^ A graph.
            -> [Cursor a] -- ^ Cursors indicating nodes to insert of a table.
            -> IO g -- ^ Graph where inserted models may be changed by being given newly assigned values such as auto incremented values.
insertNodes graph cs = do
    -- Gets table schema of `a`.
    ta <- readSchema $ symbolVal (Proxy :: Proxy (RW'Name a))

    let edgeProxies = Proxy :: Proxy g

    -- Gets list where each item has a name of foreign key column and a function getting its SqlValue from a cursor.
    let foreigns = catMaybes $ mapEdges graph (Proxy :: Proxy a) edgeProxies (resolveRelations ta) :: [(String, Cursor a -> Maybe SqlValue)]

    -- Function to remove auto increment column from the list of columns to insert.
    let removeAuto as = case L.findIndex isAutoIncrement (tableColumns ta) of
                            Just i -> take i as ++ drop (i+1) as
                            Nothing -> as

    -- Gets list of cursors where each item is a list of pairs of column name and its value.
    -- vs :: [[for cursor1 (col1, val1), (col2, val2), ...], [for cursor2 (,)....], ...]
    let vs = flip map cs $ \c ->
            -- Collects edges from a and concatenates fields of a model and foreign key columns of the edges.
            let r = getRecord $ c @< graph
                relValues = map (toSql . ($ c)) $ map snd foreigns
            in removeAuto $ zip (recordFields r ++ map fst foreigns) (recordValues r ++ relValues)

    sequences <- insert ta (map fst (vs !! 0)) (map (\vs' -> map snd vs') vs)

    return $ maybe graph (_swapAutoIncrementalValue graph ta cs) sequences

-- | Swaps auto incremented values of inserted models.
_swapAutoIncrementalValue :: (GraphContainer g a, RecordWrapper a)
                          => g -- ^ Graph.
                          -> TableMeta -- ^ Table schema.
                          -> [Cursor a] -- ^ Cursors to inserted models.
                          -> [Int] -- ^ Auto incremented values generated by the insertion.
                          -> g -- ^ Graph where values of auto incremented columns are modified.
_swapAutoIncrementalValue graph t cs vs = snd $ (`runState` graph) $ do
    let autoCol = L.find isAutoIncrement (tableColumns t)
    case autoCol of
        Just ac -> forM_ (zip cs vs) $ \(c, v) ->
                    let m = c @< graph
                        r = setFieldValue (getRecord m) (columnName ac) (toSql v)
                    in (updateRecord m r) /<< c
        Nothing -> return ()

-- | Inserts records into database.
insert :: (WithDB db)
       => TableMeta -- ^ Table schema.
       -> [String] -- ^ Column names.
       -> [[SqlValue]] -- ^ Column values of records.
       -> IO (Maybe [Int]) -- ^ Returns the list of generated auto incremented values if any.
insert _ _ [] = return Nothing
insert t cols vs = do
    context <- readIORef ?db 
    let conn = connect context
    -- TODO:
    -- The number of records one insertion can handle at maximum should be configurable.
    forM_ (_segment' 1000 vs) (_insert conn t cols)

    if L.any isAutoIncrement (tableColumns t)
        then do
            -- TODO:
            -- This implementation is only for PostgreSQL.
            stmt <- prepare conn "SELECT lastval()"
            execute stmt []
            row <- fetchRow stmt
            return $ row >>= \row' -> Just (fromSql (row' !! 0) :: Int)
                         >>= \v' -> Just [v' - length vs + 1 .. v']
        else
            return Nothing

-- | Executes an insertion.
_insert :: (WithDB db, IConnection c)
        => c -- ^ Database connection.
        -> TableMeta -- ^ Table schema.
        -> [String] -- ^ Column names.
        -> [[SqlValue]] -- ^ Column values of records.
        -> IO Integer -- ^ Returns the number of records inserted actually.
_insert conn t cols vs = do
    let q = _insertQuery t cols (length vs)
    stmt <- prepare conn q
    execute stmt $ concat vs

-- | Splits a list into lists of a certain length.
_segment' :: Int -- ^ A lenght of a list.
          -> [a] -- ^ A list.
          -> [[a]] -- ^ Split list.
_segment' n [] = []
_segment' n as = take n as : _segment' n (drop n as)

-- | Creates insertion query.
-- TODO:
-- This function assumes the RDBMS can deal with insertion query of multiple records.
-- Some RDBMSs such as PostgreSQL or MySQL have the feature, but not all have it.
_insertQuery :: TableMeta -- ^ Table schema.
             -> [String] -- ^ Column names to insert.
             -> Int -- ^ The number of records to insert.
             -> String -- ^ Query string.
_insertQuery t cols n = q ++ L.intercalate ", " (L.replicate n h)
    where
        q = "INSERT INTO " ++ tableName t ++ " (" ++ L.intercalate ", " cols ++ ") VALUES "
        h = "(" ++ holder (length cols) ++ ")"